import json
import re
import time
from operations import AddOperation, SubOperation, MulOperation, DivOperation
from database import SQLiteDataSink

# Token types used in parsing and interpreting the equations
INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN,  ATTR, REGEX, COMMA, STRING = (
    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'ATTR', 'REGEX', 'COMMA', 'STRING'
)


class Token:
    """
    Represents a single token in the input.
    Each token has a type and a value.
    """
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        return f'Token({self.type}, {repr(self.value)})'

    def __repr__(self): # Magic function
        return self.__str__()


class Lexer:
    """
    Responsible for breaking down the input string (equation) into tokens.
    """
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def advance(self):
        """Moves to the next character in the input."""
        self.pos += 1
        self.current_char = self.text[self.pos] if self.pos < len(self.text) else None

    def skip_whitespace(self):
        """Skips over whitespace characters."""
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """Handles numeric values."""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def string(self):
        """Handles string literals for regex patterns."""
        result = ''
        self.advance()  # Skip the opening quote
        while self.current_char is not None and self.current_char != '"':
            result += self.current_char
            self.advance()
        self.advance()  # Skip the closing quote
        return result

    def get_next_token(self):
        """
        Identifies the next token in the input string.
        Returns a token object or raises an error if no valid token is found.
        """
        while self.current_char is not None:
            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char.isalpha():
                word = ''
                while self.current_char is not None and self.current_char.isalnum():
                    word += self.current_char
                    self.advance()
                if word == 'Regex':
                    return Token(REGEX, word)
                elif word == 'ATTR':
                    return Token(ATTR, word)

            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')

            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')

            if self.current_char == '*':
                self.advance()
                return Token(MUL, '*')

            if self.current_char == '/':
                self.advance()
                return Token(DIV, '/')

            if self.current_char == '(':
                self.advance()
                return Token(LPAREN, '(')

            if self.current_char == ')':
                self.advance()
                return Token(RPAREN, ')')

            if self.current_char == ',':
                self.advance()
                return Token(COMMA, ',')

            if self.current_char == '"':
                return Token(STRING, self.string())

            raise Exception('Invalid character (lexical analysis).')

        return None


class AST:
    """
    Base class for Abstract Syntax Tree nodes.
    Other specific node types will inherit from this class.
    """
    pass


class BinOp(AST):
    """
    Represents a binary operation (e.g., addition, subtraction).
    """
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right


class Num(AST):
    """
    Represents a numeric value in the AST.
    """
    def __init__(self, token):
        self.token = token
        self.value = token.value


class Regex(AST):
    """
    Represents a regex operation in the AST.
    """
    def __init__(self, attr, pattern):
        self.attr = attr
        self.pattern = pattern


class Parser:
    """
    Parses tokens generated by the Lexer and builds the AST.
    """
    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = self.lexer.get_next_token()
        self.attr_value = None

    def eat(self, token_type):
        """Consumes the current token if it matches the expected type."""
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            raise Exception('Syntax error (parsing).')

    def factor(self):
        """Parses factors (numbers, attributes, parentheses, or regex)."""
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == ATTR:
            self.eat(ATTR)
            return Num(Token(INTEGER, self.attr_value))
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node
        elif token.type == REGEX:
            return self.regex()
        else:
            raise Exception('Unexpected token.')

    def regex(self):
        """Parses regex operations."""
        self.eat(REGEX)
        self.eat(LPAREN)
        attr = self.current_token
        self.eat(ATTR)
        self.eat(COMMA)
        pattern = self.current_token
        self.eat(STRING)
        self.eat(RPAREN)
        return Regex(attr, pattern)

    def term(self):
        """Parses multiplication and division operations."""
        node = self.factor()
        while self.current_token and self.current_token.type in (MUL, DIV):
            token = self.current_token
            self.eat(token.type)
            node = BinOp(left=node, op=token, right=self.factor())
        return node

    def expr(self):
        """Parses addition and subtraction operations."""
        node = self.term()
        while self.current_token and self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            self.eat(token.type)
            node = BinOp(left=node, op=token, right=self.term())
        return node

    def parse(self):
        """Initiates the parsing process."""
        return self.expr()


class NodeVisitor:
    """
    Base visitor class for traversing and interpreting the AST nodes.
    The visit method dynamically dispatches the node to the appropriate visitor method based on the node type.
    If no specific visitor method is found, it calls the generic_visit method.
    """
    def visit(self, node):
        # Calls the appropriate visit method based on the node type
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        # For unsupported node types
        raise Exception(f'No visit_{type(node).__name__} method')


class Interpreter(NodeVisitor):
    """
    Interpreter class for evaluating AST nodes, supporting arithmetic operations and regex matching.
    """
    def __init__(self, parser, attr_value):
        self.parser = parser
        self.attr_value = attr_value
        # maps operation types to corresponding operation classes
        self.operations = {
            'PLUS': AddOperation(),
            'MINUS': SubOperation(),
            'MUL': MulOperation(),
            'DIV': DivOperation()
        }

    def visit_BinOp(self, node):
        """
        Visits a binary operation node (e.g., addition, subtraction) and evaluates it.
        Applies the appropriate operation (PLUS, MINUS, MUL, DIV) on the left and right child nodes.
        """
        operation = self.operations.get(node.op.type)
        if operation:
            return operation.apply(self.visit(node.left), self.visit(node.right))
        else:
            raise ValueError(f"Unsupported operation: {node.op.type}")

    def visit_Num(self, node):
        """
        Visits a number node and returns its value.
        """
        return node.value

    def visit_Regex(self, node):
        """
        Visits a regex node and performs regex matching on the attribute value.
        Returns a boolean indicating if the pattern matches the attribute value.
        """
        pattern = node.pattern.value
        return str(bool(re.match(pattern, self.attr_value)))

    def interpret(self):
        """
        Starts the interpretation process by parsing the input equation and visiting the root node.
        Returns the final result of the AST evaluation.
        """
        tree = self.parser.parse()
        return self.visit(tree)


def process_message(message, equation):
    message_obj = json.loads(message)
    attr_value = message_obj.get("value", "")  # get returns default value if not found

    # Check if attr_value is numeric
    try:
        numeric_value = float(attr_value)
    except ValueError:
        numeric_value = None

    lexer = Lexer(equation)
    parser = Parser(lexer)

    try:
        if "Regex" in equation:  # Handles regex equations
            interpreter = Interpreter(parser, attr_value)
        else:  # Handles arithmetic equations
            if numeric_value is None:
                raise ValueError(f"Non-numeric value '{attr_value}' cannot be used in arithmetic equations")
            parser.attr_value = numeric_value  # Pass numeric value to parser
            interpreter = Interpreter(parser, str(numeric_value))

        tree = parser.parse()
        if tree is None:  # Ensuring tree is valid
            raise Exception("Failed to parse equation: Invalid AST")

        result = interpreter.visit(tree)

        output_message = {
            "asset_id": message_obj["asset_id"],
            "attribute_id": "output_" + message_obj["attribute_id"],
            "timestamp": message_obj["timestamp"],
            "value": result
        }
        return output_message

    except Exception as e:
        raise Exception(f"Error processing message: {e}")


class FileReader:
    def __init__(self, file_path):
        self.file_path = file_path
        self.last_position = 0

    def read_new_records(self):
        """Read new records from the file starting from the last position."""
        with open(self.file_path, "r") as file:
            file.seek(self.last_position)
            records = file.readlines()
            self.last_position = file.tell()
        return [record.strip() for record in records if record.strip()]


class DataProcessor:
    def __init__(self, equation, data_sink):
        self.equation = equation
        self.data_sink = data_sink

    def process_records(self, records):
        """Processes a batch of records."""
        for record in records:
            try:
                output_message = process_message(record, self.equation)
                self.data_sink.write_message(output_message)
                print(output_message)
            except Exception as e:
                print(f"Error processing record: {record}, Error: {e}")


def read_equation(config_file):
    """Reads the equation from the config file."""
    with open(config_file, "r") as file:
        return file.read().strip()


def main():
    input_file = "data.txt"
    db_name = "processed_data.db"
    config_file = "config.txt"

    # initialize dependencies
    equation = read_equation(config_file)
    data_sink = SQLiteDataSink(db_name)
    file_reader = FileReader(input_file)

    # create the processor
    processor = DataProcessor(equation, data_sink)

    try:
        while True:
            new_records = file_reader.read_new_records()
            processor.process_records(new_records)
            time.sleep(5)
    finally:
        data_sink.close()

if __name__ == "__main__":
    main()